什么是数组和指针
    数组是用于储存多个相同数据的集合。
    指针：相当于是一个变量，但是它和其它变量不一样，它存放的是其它变量在内存中的地址。

赋值：
    同类型指针可以相互赋值，数组不行，只能一个一个元素的赋值或者copy

存储方式：
    ·数组：数组在内存中是连续存放的，开辟一块连续的内存空间，数组是根据数组的下标进行访问的，
    多维数组在内存中是按照一位数组存储的，只是在逻辑上是多维的。

数组的存储空间，不是在静态区上就是在栈上。

    ·指针：指针很灵活，它可以指向任意类型的数据。指针的类型说明了他所指向的内存空间的地址。
指针本身就是一个变量，加上它存放的也是变量，所以指针的存储空间不能确定。

求sizeof:
    数组所占存储空间大小：sizeof(数组名)
    数组大小：sizeof(数组名)/sizeof(数据类型)

在32位平台下，无论指针的类型是什么，sizeof都是4，在64位平台下，sizeof都是8字节。

初始化：
    char a[] = {"Hello"};
    char b[] = {'H','e'};   //没有结束符
    char c[] = {'H','e','l','l','o','\0'};//按照字符初始化

传参：
    ·数组：
    数组传参时，会退化为指针。
    1.退化：c语言只会以值拷贝的方式传递参数，参数传递时，如果直接拷贝整个数组，效率会大大降低，并且当
参数位于栈上时，太大的数组拷贝会导致栈溢出。
    2.因此，c语言将数组的传递进行了退化。拷贝数组时，将数组名看作常量指针，传递数组首元素的地址。



## c语言编译过程
1. 预编译
   将.c的头文件展开、宏展开。生成.i文件。预处理操作不会进行语法检查。
2. 编译
   将预处理之后的.i文件生成.s汇编文件。
3. 汇编
   将.s汇编文件生成.o目标文件。
4. 链接
   将.o文件链接成可执行文件。


## if和switch区别
if用来判定多给的条件是否满足，根据判定的结果决定执行的操作。
if语句有真和假两种返回值，返回值类型为bool。
从表达结构上的区别：
if (表达式)
    语句；
if (表达式)
    语句1；
    else
    语句2；
if (表达式1)
    语句1；
    else if(表达式2)
    语句2；
    else
    语句3；



switch是多分支选择语句，整形表达式的结果为多少，就从第几个case进入，
然后进行判断。
switch语句又称为情况选择语句或开关语句。
也是分支语句的一种，用于对多种情况进行不同的处理。

if语句可以进行大小范围的变化。
if语句可以对浮点数进行判断。
switch语句只能进行相等与否的判断。
switch语句只能进行整数的判断。
进行整数判断时，case标签只能是常量。

一般情况下，switch比if-else效率更高。因为switch内部使用了Binary Tree算法，不管有多少case，
都只计算一次值，直接跳转，不需要逐个比较查询，除非if-else的第一个就位镇。
Binary tree 算法。


## c语言中的大端和小端的区别
什么是大端和小端：
    大端：高位字节放在内存的低地址端，低位字节放在内存的高地址端。地址由小到大增加，数据从高位到低位一般更符合
我们的阅读习惯。
    小端：低位字节放在内存的低地址端，高位字节放在内存的高地址端
简单概括就是字节的那一段存放在起始地址处。
有什么用：

大小端应用场景：
    芯片字节序：大端，符合阅读习惯
    网元字节序：小端，ARM大部分是小端
    网络字节序：大端，硬性规定。

大小端由cpu决定，但编译器也能指定编译模式为小端。
我们常用的x86模式是小端模式，而KEIL c51是大端模式。很多的ARM，DSP都为小端模式，。
有些ARM处理器，还可以由硬件来选择是大端模式还是小端模式。

下面这段代码可以用来测试你的编译器是大端模式还是小端模式：
```
#include<stdio.h>

int main()
{
    short int x;

    char x0,x1;

    x = 0x1122;

    x0 = ((char*)&x)[0];

    x1 = ((char*)&x)[1];

    printf("x0 = 0x%x, x1 = 0x%x",x0,x1);   //若x0 = 0x22，则是小端，否则。。。
    //大转小会强制转换为数组。会用到下标
    return 0;


}

```

## define和const区别
一、编译阶段不同
define宏定义是在预处理阶段展开的， 如#define first x

const 实在编译、运行阶段才展开      如const int P = 1024;
define是一个命令不用加; 而const是一个语句，需要加;

二、类型和安全检查不同
define无类型，不是类型安全的，不会进行类型检查，仅仅展开
const有类型，是类型安全的，会进行类型检查

三、内存占用不同
define仅仅是字符替换，程序中每次出现都要进行字符替换，所以程序中会有很多define宏的
副本，就会产生很多内存损耗。但是其本身并未分配内存，用到才分配。且其仅作替换

const定义的值是常量不能改变，但会分配内存空间，但也就分配一次，之后的程序并不用再分配。
而且编译器通常不为普通const常量分配存储空间，而是将他们保存在符号表中，，
这使得它称为编译期间的常量，没有了存储与读内存的操作，使得他的效率也很高。


## c语言的标准库函数
<assert.h>
c标准库的assert.h头文件提供了一个名为assert的宏，assert()是一个调试程序时经常使用的宏，
它通常用于验证程序做出的假设，当程序中出现了错误，非法的数据，则会中止程序以避免更严重的后果，
同时也便于查找错误。

<errno.h>
c标准库中的errno.h头文件定义了整数变量errno,它主要通过系统调用来设置，在错误事件中的
某些库函数表明发生了什么错误。头文件errno.h在启动程序时，即将errno设置为0.
其中主要有三种用法：
1.C库宏extern int errno主要是通过系统调用设置的函数，在错误事件中的某些库函数表明发生了什么错误。

2.C库宏EDOM表示一个域错误，它在输入参数超出教学函数定义的域时发生，在errno中将其设置为EDOM。
声明：#define EDOM A

3.C库宏ERANG表示一个范围错误，他在输入参数超出教学函数定义的范围时发生，在errno中将其设置为ERANGE
声明：#define ERANGE A

<time.h>
C标准库中的time.h头文件定义了四个变量类型、两个宏和各种操作日期和时间的函数。
1.库变量：
size_t:     无符号整数类型，是sizeof关键字的结果
clock_t:    适用存储器时间类型
time_t is:  适用存储日历时间类型
struct tm:  适用保存时间和日期的结构

2.tm结构的定义：
struct tm{
    int tm_sec;     //秒，范围从0到59
    int tm_min;     //分，范围从0到59
    int tm_hour;    //小时，0~23
    int tm_mday;    //一个月中的第几天，1~31
    int tm_mon;     //月，0~11
    int tm_year;    //自1900年起的年数
    int tm_wday;    //一周中的第几天，0~6
    int tm_yday;    //一年中的第几天，0~365
    int tm_isdst;   //夏令时
};

3.头文件time.h中的定义宏：
NULL：          空指针常量
CLOCKS_PER_SEC: 每秒处理器时钟个数


## 递归
递归，就是在运行的过程中调用自己

构成递归需要具备的条件：
1.子问题需要与原始问题为同样的事，且更为简单。
2.不能无限制调用本身，必须有个出口，化简为非递归状况处理。

递归模板：
1.调用自己
2.有中止条件
中止条件要在递归最开始的位置，否则会永远退不出来，出现堆栈溢出异常

```
public static int f1(int n){
    if(n < 1)
    {
        return 0;

    }
    else if(n == 1 || n == 2)
    {
        return 1;
    }

    return f1(n-1) + f1(n-2);
    

}

顺序求法
public static int f2(int n)
{
    if(n < 1)
    {
        return 0;
    }
    else if(n == 1 || n ==2)
    {
        return 1;
    }
    int res = 1;
    int pre = 1;
    int temp = 0;

    for(int i = 3; i < n; i++)
    {
        temp = res;
        res = pre + res;
        pre = temp;
    }
}




```


## c语言中常用的三种排序算法
冒泡排序：
思想在于，那相邻的两个元素进行比较，从小到大排序意味着如果前一个元素比后一个大
就要交换位置。

两个条件：
1.假设有7个数待排序，而当你排了6次后，最后一个数自然也是有序的，所以不用排了，因此7个数只需要排6次,n个数只需要排n-1次
2.n-1趟
实现如下
```
void bubble_short(int arr[], int n)
{
    for(int i = 0; i < n - 1; i++)
    {
        for(int j = 0; j <  n - 1 - i; j++)
        {
            if(arr[j] > arr[j+1])
            {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

```


选择法排序
那两个数进行比较，如果从小到大排序，就找出最小值，同最小值交换，如果从大到小排序，
就找出最大值，同最大值交换。
```
void selective_sort(int arr[], int n)
{
    int min = i;
    for(int i = 0; i < n - 1; i++)
    {
        if(arr[min] > arr[j])
        {
            min = j;
        }
    }

    //只要最小值不是第一个，就交换
    if(min != i)
    {
        int temp = arr[min];
        arr[min] = arr[i];
        arr[i]  = temp;
    }
}


```

插入法排序
插入排序的思路是从第二个位置开始插入数据，如果前一个比插入元素大，那么数组
元素都向后移动一位，再将元素插入
要满足的条件：
1.从第二个元素开始，因为前两种排序法一样，第一个或者最后一个都可以算作有序

```
void insert_sort(int arr[], int n)
{
    int current = 0, i, j;

    for(i = 1; i < n; i++)
    {
        current = arr[i];
        for(j = i - 1; j >= 0 ; j--)
        {
            if(arr[j] > current)
            {
                arr[j + 1] = arr[j];
            }
            else
            {
                break;
            }
        }
        arr[j] = current;
    }
}

```

## 并口和串口的区别
一般来说，并口可以一次性传输多个数据，传输应该更快，但由于实际的限制，并口并没有得到普及。

1.并口端口
并行接口，称为并口
电脑常见的并行端口是使用的25针D型链接头。所谓“并行”是指通过并行线路同时传输8位数据，从而
大大提高了传输速度，但是并行线路的长度受到限制，因为长度增加，干扰会增加，并且数据
容易出错。
目前并行接口主要用作打印机端口等。

并口三种工作模式：
ssp：
epp
ecp：相对高级的并口工作模式，但存在更多兼容性问题。


串行端口：
串口，串行通信接口，即COM口
它包括RS-232-C，USB、RS-422等，USB是近年来开发的新接口标准，主要用于高速数据传输领域。

通用串行总线(Univeral Serial Bus)缩写位USB，它是由英特尔，微软，康柏，IBM，NEC和Northern Telcom等多家主要制造商发起的一种新型外围设备接口标准。USB接口是计算机主板上的四针接口。中间的两个引脚传输数据，两侧的两个引脚为外围设备供电。

USB接口速度快，连接简单，无需外接电源，传输速度12Mbps，最新的USB2.0可以达到480Mbps；电缆的最大长度为5米，USB电缆有4根电线，2根信号线和2根电源线，可提供5伏电源，USB电缆分为屏蔽型和非屏蔽型。屏蔽电缆的传输速度可以达到12Mbps，价格更高。非屏蔽电缆的速度为1.5Mbps，但价格便宜。USB最多可串联连接127个设备；支持热插拔功能。

3.串口与并口的区别
串行端口被描述为通道，而并行端口则表示有8条通道可以同时传输也就是一个字节的数据。
但是由于8位通道之间的相互干扰，他不是并行快速的。在传输过程中速度会受到限制。并且在发生传输错误时，要重新传输8位数据。
串行端口没有干扰，传输错误也只重新发送一位。因此他比并行处理要快。



## 运算器控制器寄存器
CPU内部主要有运算器，控制器，寄存器三大部分组成。
运算器负责算术运算和逻辑运算
控制器负责应对所有的信息情况，调度运算器把计算做好。
寄存器可用来暂存指令、数据和地址。既要对接控制器的命令，传达命令给运算器；
还要帮助运算器记录处理完和将要处理的数据。
寄存器包括数据寄存器和指令寄存器
。。。。
https://blog.csdn.net/weixin_56502375/article/details/130083363?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169648278716800182181917%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=169648278716800182181917&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-130083363-null-null.142^v94^insert_down1&utm_term=%E8%BF%90%E7%AE%97%E5%99%A8%E6%8E%A7%E5%88%B6%E5%99%A8%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%9C%E7%94%A8&spm=1018.2226.3001.4187



## CPU为什么不直接从硬盘读取数据
首先，计算机全部是冯结构，存储设备分为内存和外存，cpu的缓存和内存都属于内存储设施，而
硬盘，光盘，U盘等都属于外存储设施，没有内存计算机无法正常工作，而外存不是必需品。

电脑内存和cpu缓存作用都差不多，其实就是一个处于CPU和硬盘的临时存放区，CPU所需访问与处理的数据都会经过这里，电脑工作时会把要用到的东西先从硬盘调用到内存里面，然后看情况进入CPU内部各级缓存，最终被CPU所调用。

同时内存也是数据暂存的地方，比如你用文本软件输入一段文字，或者用画图软件画一幅画，在你未按保存按键或者软件帮你自动保存之前这些东西都是放在内存里面的，你不保存的话这些数据就会被直接丢弃，这样可以减少硬盘的读写操作。

CPU可以直接从硬盘里调用数据，然而这样太慢了，而内存则比硬盘快得多，把用有的东西先放入内存里面，CPU调用起来就快得底盘，这样可以确保CPU的高效工作，如果每次都访问硬盘拿数据那就太慢了，你看下你电脑内存占用爆表的时候就知道什么情况了。

至于说现在的SSD已经很快了，但是其读写速度尤其是延迟还是完全不能够替代内存的作用。
现在大多数SSD延迟都是us极的，而内存的延迟一般都是ns级别的，差了将近1000倍。

## 嵌入式系统中ROM、RAM、Refister
ROM是只读存储器，数据掉电不丢失
RAM是随机存储器，数据掉电丢失
Register是寄存器，用来暂时存放相关指令信息或数据信息的硬件设备。


## CPU、内存、虚拟内存、硬盘之间的关系
1.CPU即中央处理器，是英语"Central Processing Unit"缩写
CPU从内存或者缓存中取出指令，放入指令寄存器，并对指令译码分解成系统指令的执行。
然后发出各种控制命令，执行各种微操作，从而完成系统指令的执行。

2.但是cpu不能直接调用存储在硬盘上的系统、程序和数据，必选先将硬盘的有关内容先放到内存中，这样才嫩
被CPU读取和运行。
因而，物理内存，是相对于硬盘这个外村而言的作为硬盘和cpu地中转站，对电脑运行速度有较大影响。

3.当运行的数据超出物理内存的容纳限度时，部分数据会自行溢出。这时，系统会将硬盘上的一部分空间模拟成
内存--虚拟内存，并将暂时不运行的程序或者不使用地数据存放到这部分的空间中，等待需要使用的时候方便及时调用。

4.由于内存是带电存储的，而且容量有限，所以要长时间的存储程序或者数据就需要用到硬盘(外存储器)，硬盘也会影响
系统速度，因为系统从硬盘中读取数据并通过总线存入内存的速度也会影响系统的快慢。

形象的比喻：CPU是工厂，硬盘是大仓库，内存是正规中转中心，虚拟内存是临时中专中心，


## 介绍stm32的时钟系统
一、什么是时钟
1。什么是时钟，对单片机有什么用？
时钟是由电路产生的周期性脉冲信号，相当于单片机的心脏，想要适用单片机的外设必须开启相应的外设时钟。
因为驱动外设的的本质是操作各种寄存器，而寄存器是由D触发器构成的，而触发器是需要时钟才能够改写值，所以要开启
对应外设的时钟。

2.stm32复杂的时钟系统一般称为时钟时钟树
stm32时钟系统的主要目的是为相对独立的模块提供时钟，主要也是为了降低整个芯片的功耗，所有的
外设时钟默认都是关闭状态，当我们适用某个外设时就要开启对应的时钟。
不同外设需要的时钟频率不同，没有必要都是用告诉时钟而造成浪费，有些外设也接收不了这么高的
频率，这也是为什么stm32有4个时钟源的原因，就是为了兼容不同速度的外设，同时降低功耗。
stm324个时钟源分别为：HSE, LSE, HSI, LSI




# C++部分，
指针和引用的区别
一、引用和指针
指针：指针就是内存地址，指针变量时用来存放内存地址的变量。不同类型的指针所占用的存储单元
长度时相同的，而存放数据的变量因数据类型不同，所占用的存储空间长度也不同。

引用：引用并不是新定义一个变量，而是给已存在的变量去一个别名，编译器不会为引用变量开辟内存空间,它和它引用的变量共用同一块内存空间.
类型& 引用变量名 = 引用实体; 引用类型和引用实体须为同种类型。
引用的主要用途是：修饰函数的形参和返回值。

在C++语言中,函数的参数和返回值的传递方式有三种:值传递,指针传递和引用传递.引用具有指针的效率,又具有变量使用的方便性和直观性.

引用体现了最小特权原则,即给予程序元素完成其功能的最小权限. 指针能够毫无约束的操作内存中的任何东西,尽管功能强大,但是非常危险.

两者的区别
·初始化：   引用在定义时必须初始化，指针没有这一硬性要求(尽量初始化，防止野指针)
·引用初始化一个实体后就不能在引用其它实体，而指针可以在任意时候指向同类型实体
·没有NULL引用，但是有nullptr指针
·在sizeof中含义不同: 引用结果为引用类型的大小,但指针始终是地址空间,所占字节个数(32位平台占4个字节)
·引用自加即实体加一，指针自加即指针向后偏移一个类型的大小
·有多级指针，但没有多级引用
·访问实体的方式不同，指针解引用，引用编译器自己处理
·引用比指针使用起来更安全

三、引用底层原理
通过编译器调试观察反汇编语言发现,引用和指针的反汇编语言是一样的(编译器帮我们将我们完成了转换).

底层实现:引用通过指针实现 (定义一个引用类型的变量相当于定义于一个指针类型的变量)

语法: 引用是别名,不是指针,没有发生拷贝(目前可以认为引用是指针的一层封装,更加简单化的指针)

注意:在语法概念上,引用就是一个别名,没有独立空间,和其引用实体共用同一块空间.但是在底层实现上实际是有空间的,因为引用是按照指针方式来实现的.


## 堆和栈的区别
1.管理方式不同
栈，有编译器自动管理，无需程序员手工控制；堆：产生和释放有程序员控制。

2.空间大小不同
栈的空间有限；堆内存可以达到4G

3.能否产生的碎片不同
栈不会产生碎片，因为栈是先进后出的队列。堆容易产生碎片，多次的new和delete会造成内存的不连续，从而造成
大量碎片。

4.生长方向不同
堆生长方式是向上的，栈是向下的。

5.分配方式不同
堆是动态分配的。栈可以是静态分配和动态分配两种，但是栈的动态分配由编译器释放。

6.分配效率不同
栈是机器系统提供的数据结构，计算机底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令。堆则是由C/C++函数库提供，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。

！  堆和栈相比，由于大量new/delete的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放。所以，我们推荐大家  尽量用栈，而不是用堆。

！  栈和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。

！  无论是堆还是栈，都要防止越界现象的发生。

## 面向对象的三大特征
封装，继承和多态


## 什么是抽象类
我们创建一个动物类，并且在这个类中创建动物对象，但是当你提到动物类，你并不知道我说的是什么动物，只有看到了具体的动物，你才知道这是什么动物，所以说动物本身并不是一个具体的事物，而是一个抽象的事物。只有真正的猫，狗才是具体的动物，同理我们也可以推理不同的动物，他们的行为习惯应该是不一样的，所以我们不应该在动物类中给出具体体现，而是给出一个声明即可。


## 虚函数和纯虚函数的区别
虚函数和纯虚函数的区别：
虚函数和纯虚函数可以出现在同一个类中，该类称为抽象基类。（含有纯虚函数的类称为抽象基类）
1、使用方式不同：虚函数可以直接使用，纯虚函数必须在派生类中实现后才能使用；
2定义形式不同：虚函数在定义时在普通函数的基础上加上 virtual 关键字，纯虚函数定义时除了加上virtual 关键字还需要加上 =0;
3、虚函数必须实现，否则编译器会报错；
对于实现纯虚函数的派生类，该纯虚函数在派生类中被称为虚函数，虚函数和纯虚函数都可以在派生类中重写；
析构函数最好定义为虚函数，特别是对于含有继承关系的类（析构函数被定义为虚函数之后，在使用指针引用时可以动态绑定，实现运行时的多态，保证使用基类指针就能够调用适当的虚构函数针对不同的对象进行清理工作。）；析构函数可以定义为纯虚函数，此时，其所在的类为抽象基类，不能创建实例化对象

说明：

抽象类对象不能作为函数的参数，不能创建对象，不能作为函数返回类型；
可以声明抽象类指针，可以声明抽象类的引用；
子类必须继承父类的纯虚函数，并全部实现后，才能创建子类的对象。




# python的优势有哪些
1.语法简单优雅，没有大括号，分号等特殊符号，极简主义思想
2.简单易学入手快，可以直接通过命令行交互环境学习python
3.免费开源自主性高
4.自动管理内存，可以专注于程序本身
5.便与移植
6.解释性
7.即面向对象，又面向过程，编程更加灵活
8.最重要的一点，丰富且强大的第三方库，而且由于Python的开源特性，第三方库也非常多，例如：在web开发、爬虫、科学计算等等

## python 常用的数据类型并举例
python常见的数据类型有int整形，float浮点型，bool布尔类型，str字符串类型
list列表类型，tuple元组类型，dict字典型，set集合型
1.int 整数类型
随便定义一个变量a = 1
age = 18

2.浮点型
定义：
f1 = 3.14

3.bool布尔类型
定义：
flag = False
Flag = True

4.str字符串类型
定义：
str1 = "徐浩中，加油！"
str_long = """
123456
"""

5.list列表类型
有序且可变的容器，可以存放多种不同的类型的元素

user_list = ["python", "加油"]
data_list = [1, True, "xu", "徐浩中"]

6.元组类型tuple
列表(list)，是一个有序且可变的容器，在里面可以存放多个不同类型的元素
元组(tuple)，是一个有序且不可变的容器，里面可以存放多个不同类型的元素。
定义：
v1 = (11, 22, 33)
v2 = ("徐浩中", "xuhaozhong")
v3 = (True, 123, "xuhaozhong", [11, 22, 33, 44], )
建议在元组最后加一个逗号，用于表示他是一个元组

7.set集合类型
集合是一个无序、可变、不允许数据重复的容器
v1 = {11, 22, 33, "hqss"}
·无序：无法通过索引取值
·可变，可以添加和删除元素
·不允许数据重复

就是想要维护一大堆不重复的数据时，就可以用它。比如：做爬虫去网上找图片的链接，为了避免链接重复，可以选择用集合去存储链接地址。

8.字典类型dict
字典是 无序、键不重复且元素只能是键值对的可变容器
·容器
·元素必须键值对
·键不重复，否则会被覆盖
·有序

## 语法缩进的意义
在python中，缩进是非常重要的一部分，它可以帮助我们更好的组织和管理代码，控制程序流程
提高代码的可读性和可维护性。
对于python解释器而言，每行代码前的缩进都是语法和逻辑上的意义，
属于强制缩进。

## python导入外部标准库
一般有两种导入方法，不同的导入方法在之后库函数的使用形式是不同的
1.直接import turtle
再通过turtle.Turtle('turtle')
import turtle as t
也很方便

2.from turtle import *
导入指定或者所有方法
就可以直接使用具体方法了


## 列表和元组区别
1.列表是动态数组，可变且可以重设长度
2.元组是静态数组，不可变，内部数据一旦创建就无法改变
3.元组缓存于Python运行时环境，这意味着我们每次使用元组时无须访问内核去分配内存。

设计哲学上不同：
列表保存相互独立对象的数据集合
元组不会改变的事务的多个属性


## 什么是字典的键和值




## 如何定义函数
用def语法创建函数
def funname(arg1, arg2, ...)
    statement
    return ...


## 如何定义类
python中，类是一种具有相同属性和方法的对象的抽象。在创建类的实例之前，需要先定义类
python中，类是一种用户自定义的数据结构，它可以表示具有相同属性和方法的对象的集合。

1.定义类
使用class关键字，首字母大写的驼峰命名法
```
class MyClass:
    my_attribute = 0

    def my_method(self):
    print("Hello World")

```

2.实例化：
在完成类的定义后，实际上并不会立即创建一个实例。这就像是一份汽车的蓝图。蓝图可以展示汽车的外观，但本身并不是一辆汽车。你无法直接驾驶蓝图，它只能用来指导真正汽车的建造，而且可以用它来制造多个汽车实例。那么，如何创建类的实例呢？
类的实例化：创建类实例时，需要使用类名来调用。可以用一下语法：
my_object = MyClass()
这将创建实例，并分配给变量my_object

3.类的方法：
方法是类的行为，它可以被多个实例调用。在类中定义方法时，需要在方法名前面添加一个self参数，它代表实例本身。

4.类的继承

5.类的初始化

6.类的实例属性

7.类的访问限制



## pip语句常用大全
1.升级pip
pip install -U pip

pip install --upgrade pip

2.安装某个包
pip install 包名字

3.安装指定版本的包
pip install 包名字==版本号

4.更新包的名字
pip install -U name

pip install --upgrade name

5.卸载某个包
pip uninatsll name

6.查看包的所有信息
pip show -f name

7.查看包有哪些最新版
pip list -o


